# DreamLog Persistent Learning Architecture

This document describes the comprehensive persistent learning system implemented for DreamLog, which provides continuous knowledge acquisition, conflict resolution, and optimization through sleep cycles.

## Overview

The persistent learning architecture enables DreamLog to:

1. **Learn Continuously**: Accumulate knowledge over time without losing previous learning
2. **Manage Conflicts**: Detect and resolve conflicts between learned and user knowledge
3. **Optimize Knowledge**: Compress and generalize knowledge during idle periods
4. **Validate Consistency**: Ensure knowledge base integrity through comprehensive validation
5. **Provide Safe APIs**: Offer high-level interfaces for knowledge injection and management

## Architecture Components

### 1. Dual Knowledge Base System (`persistent_learning.py`)

The core of the system uses two separate knowledge bases:

- **KB_1 (Learned Knowledge)**: Contains facts and rules generated by LLM inference
- **KB_2 (User Knowledge)**: Contains user-injected facts and rules (ground truth)

**Key Features:**
- Automatic conflict detection between KB_1 and KB_2
- Multiple conflict resolution strategies (UserTrustStrategy, ConservativeStrategy)
- Version snapshots with complete history tracking
- Performance metrics and query tracking
- Persistent storage with automatic save/load

**Usage:**
```python
from dreamlog.persistent_learning import PersistentKnowledgeBase, UserTrustStrategy

# Initialize
kb = PersistentKnowledgeBase(storage_path)

# Add learned knowledge (from LLM)
kb.add_learned_knowledge(facts, rules)

# Add user knowledge (ground truth)
conflicts = kb.add_user_knowledge(user_facts, user_rules)

# Resolve conflicts
kb.resolve_conflicts(UserTrustStrategy())

# Query combined knowledge
solutions = kb.query_with_tracking(goals)
```

### 2. Knowledge Validation System (`knowledge_validator.py`)

Comprehensive validation to ensure knowledge base consistency and correctness:

- **ConsistencyTest**: Detects logical contradictions
- **CompletenessTest**: Verifies expected query results
- **PreservationTest**: Ensures changes don't break existing behavior
- **SampleQueryGenerator**: Creates test queries for validation

**Usage:**
```python
from dreamlog.knowledge_validator import KnowledgeValidator

validator = KnowledgeValidator()
validator.create_standard_tests(kb)
report = validator.validate(kb)

print(f"Success rate: {report.success_rate:.1f}%")
print(f"Critical failures: {len(report.critical_failures)}")
```

### 3. Sleep Cycle Management (`sleep_cycle.py`)

Automated knowledge optimization during idle periods:

**Sleep Phases:**
- **Light Sleep**: Basic cleanup (duplicate removal, optimization)
- **Deep Sleep**: Rule generalization and consolidation  
- **REM Sleep**: Creative hypothesis generation (future enhancement)

**Operations:**
- **DuplicateRemover**: Eliminates redundant facts and rules
- **SubsumptionCompressor**: Removes subsumed knowledge
- **RuleGeneralizer**: Creates general rules from patterns

**Usage:**
```python
from dreamlog.sleep_cycle import SleepCycleManager, SleepPhase

manager = SleepCycleManager(persistent_kb)

# Start background sleep cycles
manager.start_background_sleep()

# Force immediate sleep cycle
report = manager.force_sleep_cycle(SleepPhase.LIGHT_SLEEP)
print(f"Compression ratio: {report.compression_ratio:.2%}")
```

### 4. Background Learning Service (`background_learner.py`)

Long-running service for persistent learning with IPC communication:

**Features:**
- TCP-based inter-process communication
- Multiple client support
- Real-time status and metrics
- Remote sleep cycle control
- Automatic session management

**Usage:**

Start the service:
```python
from dreamlog.background_learner import BackgroundLearner

service = BackgroundLearner(storage_path, ipc_port=7777)
service.start()
```

Connect from client:
```python
from dreamlog.background_learner import BackgroundLearnerClient

client = BackgroundLearnerClient(7777)

# Add knowledge
result = client.add_user_knowledge(facts, rules)

# Query
solutions = client.query(goals)

# Control sleep cycles
report = client.force_sleep_cycle(SleepPhase.LIGHT_SLEEP)
```

### 5. Learning API (`learning_api.py`)

High-level API for safe knowledge injection and management:

**Injection Modes:**
- **STRICT**: Reject on any conflict or validation failure
- **PERMISSIVE**: Auto-resolve conflicts, continue on warnings
- **INTERACTIVE**: User-guided conflict resolution
- **BATCH**: Accumulate changes, resolve at end

**Usage:**
```python
from dreamlog.learning_api import LearningAPI, InjectionMode, LearningMode

api = LearningAPI(
    storage_path,
    learning_mode=LearningMode.ACTIVE,
    injection_mode=InjectionMode.PERMISSIVE
)

# Inject knowledge from strings
result = api.inject_knowledge_from_strings(
    fact_strings=["parent(john, mary)"],
    rule_strings=["grandparent(X,Z) :- parent(X,Y), parent(Y,Z)"]
)

# Query
solutions = api.query_knowledge("grandparent(john, X)")

# Monitor progress
metrics = api.get_system_metrics()
```

### 6. Logging and Error Tracking (`logging_config.py`)

Comprehensive logging system with structured logging and error tracking:

**Features:**
- Structured JSON logging for performance analysis
- Component-specific log levels
- Rotating log files with size limits
- Performance event tracking
- Global error tracking with statistics

**Usage:**
```python
from dreamlog.logging_config import setup_logging, get_logger

# Setup logging
setup_logging(log_dir="/path/to/logs", enable_structured_logging=True)

# Get logger
logger = get_logger(__name__)
logger.log_knowledge_injection(facts=10, rules=5, conflicts=2, execution_time=150.0)
```

## Key Design Principles

### 1. Safety First
- All knowledge changes go through validation
- Conflicts are detected and reported before corruption
- Rollback mechanisms for failed operations
- Comprehensive error handling and logging

### 2. Continuous Learning
- Knowledge persists across sessions
- Incremental learning without data loss
- Background optimization during idle periods
- Performance tracking and improvement metrics

### 3. User Control
- User knowledge always takes precedence in conflicts
- Multiple resolution strategies available
- Transparent conflict reporting
- Safe injection modes for different use cases

### 4. Scalability
- Background service supports multiple clients
- Efficient indexing and query optimization
- Configurable sleep cycle intervals
- Memory-efficient storage formats

### 5. Observability
- Comprehensive metrics and monitoring
- Detailed logging of all operations
- Progress tracking and trend analysis
- Performance optimization insights

## Configuration

### Sleep Cycle Configuration
```python
from dreamlog.sleep_cycle import SleepCycleConfig
from datetime import timedelta

config = SleepCycleConfig(
    light_sleep_interval=timedelta(minutes=30),
    deep_sleep_interval=timedelta(hours=4),
    rem_sleep_interval=timedelta(hours=8),
    min_idle_time=timedelta(minutes=5),
    require_validation=True,
    backup_before_sleep=True
)
```

### Learning API Configuration
```python
api = LearningAPI(
    storage_path="/path/to/storage",
    learning_mode=LearningMode.ACTIVE,          # ACTIVE, PASSIVE, VALIDATION, EXPERIMENTAL
    injection_mode=InjectionMode.PERMISSIVE,    # STRICT, PERMISSIVE, INTERACTIVE, BATCH
    use_background_service=True,                # Use background service or direct mode
    background_port=7777
)
```

## Examples and Demos

### Basic Usage Demo
```bash
PYTHONPATH=/path/to/dreamlog python examples/persistent_learning_demo.py
```

This demonstrates:
- Basic persistent learning operations
- Conflict detection and resolution
- Sleep cycle operations
- High-level Learning API usage
- Knowledge validation workflows

### Background Service Demo
```bash
PYTHONPATH=/path/to/dreamlog python examples/background_service_demo.py
```

This demonstrates:
- Background service lifecycle
- Multiple client connections
- Service persistence across restarts
- Remote operation control

## Testing

Comprehensive test suite covering all components:

```bash
# Run all persistent learning tests
python -m pytest tests/test_persistent_learning.py -v

# Run specific test categories
python -m pytest tests/test_persistent_learning.py::TestPersistentKnowledgeBase -v
python -m pytest tests/test_persistent_learning.py::TestKnowledgeValidator -v
python -m pytest tests/test_persistent_learning.py::TestSleepCycle -v
python -m pytest tests/test_persistent_learning.py::TestIntegration -v
```

## Performance Considerations

### Storage
- JSON-based persistence for human readability
- Incremental saves to minimize I/O
- Configurable backup retention
- Efficient indexing for large knowledge bases

### Memory
- Lazy loading of historical versions
- Configurable cache sizes
- Memory-efficient term representations
- Garbage collection of unused data

### Network
- TCP-based IPC for reliability
- JSON message format for interoperability
- Connection pooling for multiple clients
- Configurable timeouts and retries

## Future Enhancements

### 1. Advanced Conflict Resolution
- Machine learning-based conflict detection
- User preference learning for resolution strategies
- Automated conflict prevention
- Context-aware resolution decisions

### 2. Enhanced Sleep Cycles
- REM sleep implementation for creative reasoning
- Adaptive sleep scheduling based on activity
- Quality-based sleep cycle triggering
- Domain-specific optimization strategies

### 3. Distributed Learning
- Multi-node knowledge sharing
- Federated learning across instances
- Consensus-based conflict resolution
- Load balancing for query processing

### 4. Integration Enhancements
- REST API for web integration
- GraphQL interface for complex queries
- Webhook support for real-time notifications
- Plugin architecture for custom extensions

## Troubleshooting

### Common Issues

**1. Storage Permission Errors**
```python
# Ensure storage directory is writable
storage_path.mkdir(parents=True, exist_ok=True)
```

**2. IPC Connection Failures**
```python
# Check port availability and firewall settings
client = BackgroundLearnerClient(port)
try:
    status = client.get_status()
except ConnectionError:
    print("Service not running or port blocked")
```

**3. Memory Usage Growth**
```python
# Configure cleanup intervals
config = SleepCycleConfig(
    light_sleep_interval=timedelta(minutes=15),  # More frequent cleanup
    max_knowledge_growth=0.1  # Trigger sleep at 10% growth
)
```

**4. Validation Failures**
```python
# Check for logical inconsistencies
validator = KnowledgeValidator()
report = validator.validate(kb)
for failure in report.critical_failures:
    print(f"Critical issue: {failure.message}")
```

## Contributing

When contributing to the persistent learning system:

1. **Follow Design Principles**: Maintain safety, transparency, and user control
2. **Add Comprehensive Tests**: Cover new functionality with unit and integration tests
3. **Update Documentation**: Keep this README and docstrings current
4. **Consider Performance**: Optimize for memory and storage efficiency
5. **Maintain Compatibility**: Don't break existing APIs without migration paths

## License

The persistent learning architecture is part of the DreamLog project and follows the same license terms.

---

This persistent learning architecture transforms DreamLog from a stateless query engine into a continuously learning system that accumulates knowledge, resolves conflicts intelligently, and optimizes itself automatically. It provides the foundation for truly intelligent logic programming with LLM integration.